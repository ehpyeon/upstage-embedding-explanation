<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>문장 유사도 도구</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Noto Sans KR', sans-serif;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
        }
        
        .main-container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            gap: 20px;
        }
        
        .left-panel {
            flex: 1;
            min-width: 0;
        }
        
        .right-panel {
            flex: 1;
            min-width: 0;
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
            height: auto;
        }
        
        .docs-container {
            display: none;
            height: auto;
            min-height: 100%;
        }
        
        .docs-container.active {
            display: block;
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #333;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 20px;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        h3 {
            font-size: 18px;
            margin-top: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="text"], input[type="password"], textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .api-container {
            display: flex;
        }
        
        .api-container input {
            flex-grow: 1;
            margin-right: 8px;
        }
        
        .api-container button {
            width: 60px;
        }
        
        button {
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #1557b0;
        }
        
        .action-btn {
            width: 100%;
            margin-top: 10px;
            padding: 12px;
            font-size: 16px;
        }
        
        .tab-container {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
            background-color: #f5f5f5;
        }
        
        .tab.active {
            background-color: #1a73e8;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        #result, #search-result {
            margin-top: 20px;
            padding: 15px;
            border-top: 1px solid #eee;
        }
        
        .result-container {
            margin-top: 20px;
            padding: 15px;
            border-top: 1px solid #eee;
        }
        
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        
        .result-table th, .result-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .result-table th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        
        .similarity-bar-container {
            width: 70%;
            background-color: #f1f1f1;
            border-radius: 4px;
            height: 20px;
        }
        
        .similarity-bar {
            height: 20px;
            border-radius: 4px;
            transition: width 0.5s ease-in-out;
        }
        
        .similarity-text {
            margin-left: 10px;
            font-weight: bold;
        }
        
        .similarity-wrapper {
            display: flex;
            align-items: center;
        }
        
        .error {
            color: #d32f2f;
            padding: 10px;
            background-color: #ffeaea;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        .success {
            color: #388e3c;
            padding: 10px;
            background-color: #eaffea;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        .sentence-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
        }
        
        .sentence-item {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .sentence-item:last-child {
            border-bottom: none;
        }
        
        /* 문서 스타일 */
        .docs-content {
            line-height: 1.6;
        }
        
        .docs-content p {
            margin-bottom: 16px;
        }
        
        .docs-content code {
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .docs-content pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        
        .docs-content ul, .docs-content ol {
            padding-left: 20px;
        }
        
        .docs-content img {
            max-width: 100% !important;
        }
        
        .docs-content blockquote {
            border-left: 4px solid #1a73e8;
            padding-left: 15px;
            margin-left: 0;
            color: #555;
        }
        
        /* 시각 정보 스타일 추가 */
        .timestamp {
            font-size: 12px;
            color: #999;
            margin-left: 8px;
        }
        
        /* 문장 목록 헤더 스타일 */
        .sentences-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .sentences-header h3 {
            margin: 0;
        }
        
        /* 작은 버튼 스타일 */
        .small-btn {
            padding: 6px 12px;
            font-size: 13px;
            background-color: #f44336;
        }
        
        .small-btn:hover {
            background-color: #d32f2f;
        }
        
        /* 섹션 구분 수평선 스타일 */
        .section-divider {
            height: 1px;
            background-color: #ddd;
            border: none;
            margin: 30px 0;
        }
        
        /* 코드 블록 스타일 */
        .code-block {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .code-header {
            background-color: #f5f5f5;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
        }
        
        .code-header h4 {
            margin: 0;
            font-size: 14px;
            color: #555;
        }
        
        .code-content {
            display: none;
            padding: 15px;
            background-color: #f8f9fa;
            overflow-x: auto;
            max-height: 400px;
        }
        
        .code-content.expanded {
            display: block;
        }
        
        .code-content pre {
            margin: 0;
            white-space: pre-wrap;
            font-family: monospace;
        }
        
        .toggle-icon {
            font-size: 18px;
            transition: transform 0.3s;
        }
        
        .toggle-icon.expanded {
            transform: rotate(180deg);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 왼쪽 패널 - 기존 기능 -->
        <div class="left-panel">
            <div class="container">
                <h1>문장 유사도 도구</h1>
                
                <div class="tab-container">
                    <div class="tab active" data-tab="calculate">유사도 계산</div>
                    <div class="tab" data-tab="save">문장 저장</div>
                    <div class="tab" data-tab="search">유사도 검색</div>
                </div>
                
                <!-- 유사도 계산 탭 -->
                <div id="calculate-tab" class="tab-content active">
                    <div class="form-group">
                        <label for="text1">문장 1:</label>
                        <input type="text" id="text1" placeholder="첫 번째 문장 입력">
                    </div>
                    
                    <div class="form-group">
                        <label for="text2">문장 2:</label>
                        <input type="text" id="text2" placeholder="두 번째 문장 입력">
                    </div>
                    
                    <div class="form-group">
                        <label for="text3">문장 3:</label>
                        <input type="text" id="text3" placeholder="세 번째 문장 입력">
                    </div>
                    
                    <button id="calculate-btn" class="action-btn">유사도 계산</button>
                    
                    <div id="result"></div>
                </div>
                
                <!-- 문장 저장 탭 -->
                <div id="save-tab" class="tab-content">
                    <div class="form-group">
                        <label for="new-sentence">새 문장:</label>
                        <input type="text" id="new-sentence" placeholder="저장할 문장 입력">
                    </div>
                    
                    <button id="save-btn" class="action-btn">문장 저장</button>
                    
                    <div id="save-result"></div>
                    
                    <div class="sentences-header">
                        <h3>저장된 문장 목록</h3>
                        <button id="reset-btn" class="small-btn">목록 초기화</button>
                    </div>
                    
                    <div id="sentences-list" class="sentence-list">
                        <p>저장된 문장이 없습니다.</p>
                    </div>
                </div>
                
                <!-- 유사도 검색 탭 -->
                <div id="search-tab" class="tab-content">
                    <div class="form-group">
                        <label for="query-sentence">검색 문장:</label>
                        <input type="text" id="query-sentence" placeholder="검색할 문장 입력">
                    </div>
                    
                    <button id="search-btn" class="action-btn">유사도 검색</button>
                    
                    <div id="search-result"></div>
                </div>
            </div>
        </div>
        
        <!-- 오른쪽 패널 - 문서 설명 -->
        <div class="right-panel">
            <div class="container">
                <h1>기능 설명</h1>
                
                <!-- 유사도 계산 문서 -->
                <div id="calculate-docs" class="docs-container active">
                    <div class="docs-content">
                        <h2>유사도 계산 기능</h2>
                        <p>이 기능은 두 개 이상의 문장 간의 의미적 유사도를 계산합니다.</p>
                        
                        <h3>작동 원리</h3>
                        <ol>
                            <li><strong>텍스트 임베딩</strong>: Upstage의 임베딩 API를 사용하여 각 문장을 고차원 벡터로 변환합니다. 이 벡터는 문장의 의미를 수치적으로 표현합니다.</li>
                            <li><strong>코사인 유사도</strong>: 변환된 벡터 간의 코사인 유사도를 계산합니다. 코사인 유사도는 두 벡터 간의 각도의 코사인값으로, -1에서 1 사이의 값을 가집니다. 1에 가까울수록 두 문장의 의미가 유사함을 나타냅니다.</li>
                            <li><strong>결과 시각화</strong>: 계산된 유사도 점수를 색상 바로 시각화하여 직관적으로 표시합니다.</li>
                        </ol>
                        
                        <hr class="section-divider">
                        
                        <h3>벡터 차원이란?</h3>
                        <p>벡터 차원을 쉽게 이해하려면 '특성 공간'이라고 생각해보세요:</p>
                        <blockquote>
                            <p>만약 사람을 설명한다고 가정해봅시다. 키, 몸무게, 나이만으로 사람을 표현한다면 이는 3차원 벡터입니다. 각 사람은 이 세 가지 특성의 조합으로 표현됩니다.</p>
                            <p>문장의 경우, 단순히 키, 몸무게, 나이와 같은 몇 가지 특성으로는 의미를 완전히 담아낼 수 없습니다. 문장의 주제, 감정, 문법적 구조, 단어 선택 등 수많은 특성이 필요합니다.</p>
                            <p>Upstage의 임베딩 모델은 문장을 수백 개의 특성(차원)으로 표현합니다. 이는 마치 수백 개의 서로 다른 관점에서 문장을 바라보는 것과 같습니다. 이렇게 많은 차원이 있기 때문에 문장의 미묘한 의미 차이까지 포착할 수 있습니다.</p>
                        </blockquote>
                        
                        <h3>예시: 입력과 출력</h3>
                        <p>다음 세 문장을 입력한다고 가정해봅시다:</p>
                        <ol>
                            <li>"오늘 날씨가 정말 좋네요."</li>
                            <li>"오늘은 날씨가 맑고 화창합니다."</li>
                            <li>"내일 시험을 봐야 해서 걱정이에요."</li>
                        </ol>
                        
                        <p>이 문장들을 임베딩하고 유사도를 계산하면 다음과 같은 결과가 나올 수 있습니다:</p>
                        
                        <div class="example-result">
                            <table class="result-table">
                                <thead>
                                    <tr>
                                        <th>문장 쌍</th>
                                        <th>유사도</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>1 vs 2</strong></td>
                                        <td>
                                            <div class="similarity-wrapper">
                                                <div class="similarity-bar-container">
                                                    <div class="similarity-bar" style="width: 92%; background-color: hsl(110, 70%, 50%);"></div>
                                                </div>
                                                <span class="similarity-text">0.92</span>
                                            </div>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><strong>1 vs 3</strong></td>
                                        <td>
                                            <div class="similarity-wrapper">
                                                <div class="similarity-bar-container">
                                                    <div class="similarity-bar" style="width: 32%; background-color: hsl(38, 70%, 50%);"></div>
                                                </div>
                                                <span class="similarity-text">0.32</span>
                                            </div>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td><strong>2 vs 3</strong></td>
                                        <td>
                                            <div class="similarity-wrapper">
                                                <div class="similarity-bar-container">
                                                    <div class="similarity-bar" style="width: 28%; background-color: hsl(34, 70%, 50%);"></div>
                                                </div>
                                                <span class="similarity-text">0.28</span>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <p>결과 해석:</p>
                        <ul>
                            <li>문장 1과 2는 모두 '오늘 날씨'에 관한 내용으로, 매우 높은 유사도(0.92)를 보입니다.</li>
                            <li>문장 1과 3, 문장 2와 3은 주제가 완전히 다르기 때문에 낮은 유사도(0.32, 0.28)를 보입니다.</li>
                            <li>이처럼 유사도 점수는 문장의 의미적 관련성을 수치화하여 보여줍니다.</li>
                        </ul>
                        
                        <hr class="section-divider">
                        
                        <h3>코사인 유사도란?</h3>
                        <p>코사인 유사도를 쉽게 이해하기 위해 다음과 같은 비유를 생각해보세요:</p>
                        <blockquote>
                            <p><strong>나침반 비유</strong>: 두 사람이 각각 나침반을 들고 서 있다고 상상해보세요. 두 사람이 가리키는 방향이 얼마나 비슷한지를 측정하는 것이 코사인 유사도입니다.</p>
                            <ul>
                                <li>두 사람이 <strong>같은 방향</strong>을 가리키고 있다면 → 코사인 유사도는 <strong>1</strong> (완전히 유사)</li>
                                <li>두 사람이 <strong>반대 방향</strong>을 가리키고 있다면 → 코사인 유사도는 <strong>-1</strong> (완전히 반대)</li>
                                <li>두 사람이 <strong>직각</strong>으로 서로 다른 방향을 가리키고 있다면 → 코사인 유사도는 <strong>0</strong> (관련 없음)</li>
                            </ul>
                            <p>문장의 경우, 각 문장은 특정 '의미 방향'을 가리키는 화살표로 생각할 수 있습니다. 두 문장이 비슷한 주제나 의미를 가지고 있다면, 그 화살표들은 비슷한 방향을 가리키게 됩니다.</p>
                        </blockquote>
                        
                        <h4>구체적인 예시</h4>
                        <p>다음 문장들의 코사인 유사도를 생각해봅시다:</p>
                        <ol>
                            <li>"오늘 날씨가 정말 좋네요."</li>
                            <li>"오늘은 날씨가 맑고 화창합니다."</li>
                            <li>"내일 시험을 봐야 해서 걱정이에요."</li>
                        </ol>
                        
                        <p>문장 1과 2는 모두 '날씨'에 관한 내용으로, 의미적으로 매우 유사합니다. 이들을 벡터로 변환하면 거의 같은 방향을 가리키는 화살표가 됩니다. 따라서 코사인 유사도는 0.92와 같이 1에 가까운 높은 값이 나옵니다.</p>
                        
                        <p>반면, 문장 1과 3은 완전히 다른 주제를 다루고 있습니다. 이들을 벡터로 변환하면 서로 다른 방향을 가리키는 화살표가 됩니다. 따라서 코사인 유사도는 0.32와 같이 낮은 값이 나옵니다.</p>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <img src="https://mblogthumb-phinf.pstatic.net/MjAyMDAzMjJfMTQx/MDAxNTg0ODU0Mzk2OTI5.2-KQ5YFGhRXcTnyG-qjlJsLL16YvHok_zkVL-UGFUk0g.TNDaeu3Ks8km3GHfjHbTyj_Y6plRp16WJ7aQ_MJihbwg.PNG.sjc02183/image.png?type=w800" alt="코사인 유사도 시각화" style="max-width: 100%;">
                            <p style="font-size: 12px; color: #666; margin-top: 5px;">코사인 유사도는 두 벡터 간의 각도(θ)의 코사인값을 측정합니다.<br>
                            <a href="https://m.blog.naver.com/sjc02183/221866765335" target="_blank" style="color: #666;">출처: 네이버 블로그 - 유사도 처리법</a></p>
                        </div>
                        
                        <h4>거리 기반 vs 각도 기반 유사도</h4>
                        <p>위 이미지는 두 가지 다른 유사도 측정 방식의 차이를 보여줍니다:</p>
                        
                        <div style="display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 20px;">
                            <div style="flex: 1; min-width: 250px;">
                                <h5>왼쪽: 거리 기반 유사도 (유클리디안 거리)</h5>
                                <ul>
                                    <li>두 점 사이의 <strong>직선 거리</strong>를 측정합니다.</li>
                                    <li>주황색 점 주변에 있는 검은색 점들이 유사하다고 판단합니다.</li>
                                    <li>좌표 공간에서 <strong>물리적으로 가까운</strong> 데이터가 유사하다고 봅니다.</li>
                                    <li>예: 두 사람의 키와 몸무게가 비슷하면 유사하다고 판단</li>
                                </ul>
                            </div>
                            
                            <div style="flex: 1; min-width: 250px;">
                                <h5>오른쪽: 각도 기반 유사도 (코사인 유사도)</h5>
                                <ul>
                                    <li>원점(0,0)에서 각 점까지의 <strong>벡터 방향(각도)</strong>을 측정합니다.</li>
                                    <li>주황색 점과 같은 방향(원점에서 그은 직선 위)에 있는 점들이 유사하다고 판단합니다.</li>
                                    <li>벡터의 <strong>크기보다 방향</strong>이 중요합니다.</li>
                                    <li>예: 두 문서가 같은 주제를 다루지만 길이가 다르더라도 유사하다고 판단</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p>문장 유사도 계산에서는 코사인 유사도가 더 적합한 경우가 많습니다. 예를 들어:</p>
                        <ul>
                            <li>"나는 오늘 행복하다"와 "나는 오늘 정말 행복하고 기쁘다"는 길이는 다르지만 의미적으로 유사합니다.</li>
                            <li>코사인 유사도는 이 두 문장의 <strong>방향(의미)</strong>이 유사함을 포착할 수 있습니다.</li>
                            <li>반면 유클리디안 거리는 단어 수 차이로 인해 두 문장을 다르게 판단할 수 있습니다.</li>
                        </ul>
                        
                        <p>이처럼 코사인 유사도는 <strong>벡터의 방향성</strong>에 초점을 맞추어, 문장의 길이보다는 <strong>의미적 유사성</strong>을 더 잘 포착합니다.</p>
                        
                        <h4>일상적인 예시</h4>
                        <p>영화 추천 시스템을 생각해보세요. 당신이 좋아하는 영화들의 특성(장르, 배우, 감독 등)을 벡터로 표현할 수 있습니다. 새로운 영화가 당신의 취향 벡터와 비슷한 방향을 가리킨다면(높은 코사인 유사도), 그 영화는 당신이 좋아할 가능성이 높습니다.</p>
                        
                        <hr class="section-divider">
                        
                        <h3>기술적 세부사항</h3>
                        <p>이 기능은 Upstage의 임베딩 API를 사용하여 텍스트 임베딩을 생성합니다. OpenAI 클라이언트를 사용하여 Upstage API에 접근합니다.</p>
                        <pre><code>client = OpenAI(
    api_key=UPSTAGE_API_KEY,
    base_url="https://api.upstage.ai/v1/solar"
)

# 각 문장에 대해 임베딩 생성
embeddings = []
for text in texts:
    response = client.embeddings.create(
        input=text,
        model="embedding-query"
    )
    embeddings.append(response.data[0].embedding)

# 코사인 유사도 계산
sim = cosine_similarity([vecs[i]], [vecs[j]])[0][0]</code></pre>
                    </div>
                </div>
                
                <!-- 문장 저장 문서 -->
                <div id="save-docs" class="docs-container">
                    <div class="docs-content">
                        <h2>문장 저장 기능</h2>
                        <p>이 기능은 문장과 그 의미적 특성을 나타내는 임베딩 벡터를 함께 저장합니다.</p>
                        
                        <h3>작동 원리</h3>
                        <ol>
                            <li><strong>텍스트 임베딩</strong>: 입력된 문장을 OpenAI의 임베딩 API를 사용하여 벡터로 변환합니다.</li>
                            <li><strong>데이터 저장</strong>: 원본 문장과 변환된 벡터를 JSON 파일에 저장합니다.</li>
                            <li><strong>목록 업데이트</strong>: 저장된 문장 목록을 화면에 표시합니다.</li>
                        </ol>
                        
                        <h3>사용 방법</h3>
                        <ol>
                            <li>OpenAI API 키를 입력합니다.</li>
                            <li>저장할 문장을 입력 필드에 입력합니다.</li>
                            <li>'문장 저장' 버튼을 클릭합니다.</li>
                            <li>문장이 저장되면 아래 목록에 추가됩니다.</li>
                        </ol>
                        
                        <h3>데이터 구조</h3>
                        <p>문장은 다음과 같은 JSON 구조로 저장됩니다:</p>
                        <pre><code>{
  "sentences": [
    {
      "text": "저장된 문장",
      "embedding": [0.123, -0.456, 0.789, ...] // 1,536 차원 벡터
    },
    ...
  ]
}</code></pre>
                        
                        <h3>기술적 세부사항</h3>
                        <p>저장된 임베딩 벡터는 후속 검색에 사용되며, 검색 시 실시간으로 임베딩을 다시 계산할 필요가 없어 효율적입니다. 벡터는 문장의 의미적 특성을 캡처하여 유사한 의미를 가진 문장을 찾는 데 사용됩니다.</p>
                        <pre><code>client = OpenAI(api_key=api_key)
response = client.embeddings.create(input=[sentence], model="text-embedding-ada-002")
embedding = response.data[0].embedding

# JSON 파일에 저장
db["sentences"].append({
    "text": sentence,
    "embedding": embedding
})</code></pre>
                    </div>
                </div>
                
                <!-- 유사도 검색 문서 -->
                <div id="search-docs" class="docs-container">
                    <div class="docs-content">
                        <h2>유사도 검색 기능</h2>
                        <p>이 기능은 입력된 문장과 저장된 문장들 사이의 의미적 유사도를 계산하여 가장 유사한 문장을 찾습니다.</p>
                        
                        <h3>작동 원리</h3>
                        <ol>
                            <li><strong>검색 쿼리 임베딩</strong>: 입력된 검색 문장을 OpenAI의 임베딩 API를 사용하여 벡터로 변환합니다.</li>
                            <li><strong>유사도 계산</strong>: 검색 쿼리 벡터와 저장된 모든 문장 벡터 간의 코사인 유사도를 계산합니다.</li>
                            <li><strong>결과 정렬</strong>: 유사도 점수가 높은 순으로 결과를 정렬합니다.</li>
                            <li><strong>결과 표시</strong>: 유사도 점수와 함께 결과를 시각적으로 표시합니다.</li>
                        </ol>
                        
                        <h3>사용 방법</h3>
                        <ol>
                            <li>OpenAI API 키를 입력합니다.</li>
                            <li>검색할 문장을 입력 필드에 입력합니다.</li>
                            <li>'유사도 검색' 버튼을 클릭합니다.</li>
                            <li>결과 영역에서 저장된 문장 중 입력 문장과 가장 유사한 문장들을 확인합니다.</li>
                        </ol>
                        
                        <h3>활용 사례</h3>
                        <ul>
                            <li><strong>의미 기반 검색</strong>: 키워드가 아닌 의미를 기반으로 한 검색이 가능합니다.</li>
                            <li><strong>유사 질문 찾기</strong>: FAQ 시스템에서 사용자 질문과 유사한 기존 질문을 찾을 수 있습니다.</li>
                            <li><strong>문서 추천</strong>: 사용자가 관심을 가질 만한 유사한 내용의 문서를 추천할 수 있습니다.</li>
                        </ul>
                        
                        <h3>기술적 세부사항</h3>
                        <p>이 검색은 벡터 공간에서의 의미적 근접성을 활용하는 '시맨틱 검색(Semantic Search)' 방식을 사용합니다.</p>
                        <pre><code>client = OpenAI(api_key=api_key)
response = client.embeddings.create(input=[query], model="text-embedding-ada-002")
query_embedding = np.array(response.data[0].embedding)

# 저장된 모든 문장과 유사도 계산
for item in db["sentences"]:
    stored_embedding = np.array(item["embedding"])
    similarity = cosine_similarity([query_embedding], [stored_embedding])[0][0]
    results.append({
        "text": item["text"],
        "similarity": round(similarity, 4)
    })

# 유사도 높은 순으로 정렬
results.sort(key=lambda x: x["similarity"], reverse=True)</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 요소 참조
            const calculateBtn = document.getElementById('calculate-btn');
            const saveBtn = document.getElementById('save-btn');
            const searchBtn = document.getElementById('search-btn');
            const resetBtn = document.getElementById('reset-btn');
            const resultDiv = document.getElementById('result');
            const saveResultDiv = document.getElementById('save-result');
            const searchResultDiv = document.getElementById('search-result');
            const sentencesListDiv = document.getElementById('sentences-list');
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            const docsContainers = document.querySelectorAll('.docs-container');
            
            // 초기 로드시 저장된 문장 목록 가져오기
            loadSentencesList();
            
            // 탭 전환 기능
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');
                    
                    // 모든 탭 비활성화
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    docsContainers.forEach(d => d.classList.remove('active'));
                    
                    // 선택한 탭 활성화
                    this.classList.add('active');
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                    document.getElementById(`${tabId}-docs`).classList.add('active');
                });
            });
            
            // 유사도 계산 버튼 클릭
            calculateBtn.addEventListener('click', function() {
                const text1 = document.getElementById('text1').value.trim();
                const text2 = document.getElementById('text2').value.trim();
                const text3 = document.getElementById('text3').value.trim();
                
                // 유효성 검사
                if (!text1 && !text2 && !text3) {
                    showError(resultDiv, '최소 두 개 이상의 문장을 입력해주세요.');
                    return;
                }
                
                // 입력된 문장만 배열에 추가
                const texts = [];
                if (text1) texts.push(text1);
                if (text2) texts.push(text2);
                if (text3) texts.push(text3);
                
                if (texts.length < 2) {
                    showError(resultDiv, '최소 두 개 이상의 문장을 입력해주세요.');
                    return;
                }
                
                // 로딩 표시
                resultDiv.innerHTML = '<p>유사도 계산 중...</p>';
                
                // API 요청
                fetch('/compute_similarity', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        texts: texts
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(resultDiv, data.error);
                        return;
                    }
                    
                    // 결과 표시 (코드 블록 포함)
                    displayResults(resultDiv, data.similarities, data);
                })
                .catch(error => {
                    showError(resultDiv, '요청 처리 중 오류가 발생했습니다: ' + error.message);
                });
            });
            
            // 문장 저장 버튼 클릭
            saveBtn.addEventListener('click', function() {
                const sentence = document.getElementById('new-sentence').value.trim();
                
                // 유효성 검사
                if (!sentence) {
                    showError(saveResultDiv, '저장할 문장을 입력해주세요.');
                    return;
                }
                
                // 로딩 표시
                saveResultDiv.innerHTML = '<p>문장 저장 중...</p>';
                
                // API 요청
                fetch('/save_sentence', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sentence: sentence
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(saveResultDiv, data.error);
                        return;
                    }
                    
                    // 성공 메시지 표시 (코드 블록 포함)
                    let html = `<div class="success">${data.message}</div>`;
                    
                    // 코드 블록 추가
                    html += createCodeBlock('API 응답 데이터', JSON.stringify(data, null, 2));
                    
                    saveResultDiv.innerHTML = html;
                    
                    // 입력 필드 초기화
                    document.getElementById('new-sentence').value = '';
                    
                    // 저장된 문장 목록 갱신
                    loadSentencesList();
                    
                    // 코드 블록 토글 이벤트 추가
                    addCodeBlockToggleEvents();
                })
                .catch(error => {
                    showError(saveResultDiv, '요청 처리 중 오류가 발생했습니다: ' + error.message);
                });
            });
            
            // 유사도 검색 버튼 클릭
            searchBtn.addEventListener('click', function() {
                const query = document.getElementById('query-sentence').value.trim();
                
                // 유효성 검사
                if (!query) {
                    showError(searchResultDiv, '검색할 문장을 입력해주세요.');
                    return;
                }
                
                // 로딩 표시
                searchResultDiv.innerHTML = '<p>유사 문장 검색 중...</p>';
                
                // API 요청
                fetch('/search_similar', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        showError(searchResultDiv, data.error);
                        return;
                    }
                    
                    // 결과 표시 (코드 블록 포함)
                    displaySearchResults(searchResultDiv, data.results, data);
                })
                .catch(error => {
                    showError(searchResultDiv, '요청 처리 중 오류가 발생했습니다: ' + error.message);
                });
            });
            
            // 리셋 버튼 클릭
            resetBtn.addEventListener('click', function() {
                if (confirm('정말로 모든 저장된 문장을 삭제하시겠습니까?')) {
                    // API 요청
                    fetch('/reset_sentences', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            showError(saveResultDiv, data.error);
                            return;
                        }
                        
                        // 성공 메시지 표시 (코드 블록 포함)
                        let html = `<div class="success">${data.message}</div>`;
                        
                        // 코드 블록 추가
                        html += createCodeBlock('API 응답 데이터', JSON.stringify(data, null, 2));
                        
                        saveResultDiv.innerHTML = html;
                        
                        // 저장된 문장 목록 갱신
                        loadSentencesList();
                        
                        // 코드 블록 토글 이벤트 추가
                        addCodeBlockToggleEvents();
                    })
                    .catch(error => {
                        showError(saveResultDiv, '요청 처리 중 오류가 발생했습니다: ' + error.message);
                    });
                }
            });
            
            // 저장된 문장 목록 로드
            function loadSentencesList() {
                fetch('/get_all_sentences')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        sentencesListDiv.innerHTML = `<p>문장 목록을 불러올 수 없습니다: ${data.error}</p>`;
                        return;
                    }
                    
                    const sentences = data.sentences;
                    
                    if (sentences.length === 0) {
                        sentencesListDiv.innerHTML = '<p>저장된 문장이 없습니다.</p>';
                        return;
                    }
                    
                    let html = '';
                    sentences.forEach((item, index) => {
                        const timestamp = item.timestamp ? `<span class="timestamp">${item.timestamp}</span>` : '';
                        html += `<div class="sentence-item">${index + 1}. ${item.text} ${timestamp}</div>`;
                    });
                    
                    sentencesListDiv.innerHTML = html;
                })
                .catch(error => {
                    sentencesListDiv.innerHTML = `<p>문장 목록을 불러올 수 없습니다: ${error.message}</p>`;
                });
            }
            
            // 오류 표시 함수
            function showError(container, message) {
                container.innerHTML = `<div class="error">${message}</div>`;
            }
            
            // 결과 표시 함수 (코드 블록 포함)
            function displayResults(container, similarities, responseData) {
                let html = '<div class="result-container">';
                html += '<h3>유사도 결과</h3>';
                
                html += '<table class="result-table">';
                html += '<thead><tr><th>문장 쌍</th><th>유사도</th></tr></thead>';
                html += '<tbody>';
                
                similarities.forEach(item => {
                    const similarityValue = item.similarity;
                    const percentage = Math.round(similarityValue * 100);
                    
                    // 유사도에 따른 색상 결정 (낮음: 빨간색, 높음: 녹색)
                    const hue = Math.min(similarityValue * 120, 120); // 0-120 범위의 색상값 (빨강->녹색)
                    const barColor = `hsl(${hue}, 70%, 50%)`;
                    
                    html += `<tr>
                                <td><strong>${item.pair}</strong></td>
                                <td>
                                    <div class="similarity-wrapper">
                                        <div class="similarity-bar-container">
                                            <div class="similarity-bar" style="width: ${percentage}%; background-color: ${barColor};"></div>
                                        </div>
                                        <span class="similarity-text">${similarityValue}</span>
                                    </div>
                                </td>
                            </tr>`;
                });
                
                html += '</tbody></table>';
                
                // 코드 블록 추가
                html += createCodeBlock('API 응답 데이터', JSON.stringify(responseData, null, 2));
                
                // 코드 블록 추가 (백엔드 코드)
                const backendCode = `# 유사도 계산 함수 (backend.py)
@app.route("/compute_similarity", methods=["POST"])
def compute_similarity():
    try:
        data = request.json
        texts = data.get("texts")

        if not texts or len(texts) < 2:
            return jsonify({"error": "최소 두 개의 문장이 필요합니다"}), 400

        # Upstage 임베딩 생성
        embeddings = get_upstage_embeddings(texts)
        
        # 임베딩을 numpy 배열로 변환
        vecs = [np.array(embedding) for embedding in embeddings]
        similarities = []

        for i in range(len(vecs)):
            for j in range(i + 1, len(vecs)):
                sim = cosine_similarity([vecs[i]], [vecs[j]])[0][0]
                similarities.append({"pair": f"{i+1} vs {j+1}", "similarity": round(sim, 4)})

        return jsonify({"similarities": similarities})
    
    except Exception as e:
        return jsonify({"error": str(e)}), 500`;
                
                html += createCodeBlock('백엔드 코드', backendCode);
                
                html += '</div>';
                
                container.innerHTML = html;
                
                // 코드 블록 토글 이벤트 추가
                addCodeBlockToggleEvents();
            }
            
            // 검색 결과 표시 함수 (코드 블록 포함)
            function displaySearchResults(container, results, responseData) {
                let html = '<div class="result-container">';
                html += '<h3>유사 문장 검색 결과</h3>';
                
                html += '<table class="result-table">';
                html += '<thead><tr><th>문장</th><th>유사도</th></tr></thead>';
                html += '<tbody>';
                
                results.forEach(item => {
                    const similarityValue = item.similarity;
                    const percentage = Math.round(similarityValue * 100);
                    const timestamp = item.timestamp ? `<span class="timestamp">${item.timestamp}</span>` : '';
                    
                    // 유사도에 따른 색상 결정 (낮음: 빨간색, 높음: 녹색)
                    const hue = Math.min(similarityValue * 120, 120); // 0-120 범위의 색상값 (빨강->녹색)
                    const barColor = `hsl(${hue}, 70%, 50%)`;
                    
                    html += `<tr>
                                <td>${item.text} ${timestamp}</td>
                                <td>
                                    <div class="similarity-wrapper">
                                        <div class="similarity-bar-container">
                                            <div class="similarity-bar" style="width: ${percentage}%; background-color: ${barColor};"></div>
                                        </div>
                                        <span class="similarity-text">${similarityValue}</span>
                                    </div>
                                </td>
                            </tr>`;
                });
                
                html += '</tbody></table>';
                
                // 코드 블록 추가
                html += createCodeBlock('API 응답 데이터', JSON.stringify(responseData, null, 2));
                
                // 코드 블록 추가 (백엔드 코드)
                const backendCode = `# 유사도 검색 함수 (backend.py)
@app.route("/search_similar", methods=["POST"])
def search_similar():
    try:
        data = request.json
        query = data.get("query")

        if not query:
            return jsonify({"error": "검색어가 필요합니다"}), 400

        # DB 로드
        db = load_sentences_db()
        if not db["sentences"]:
            return jsonify({"error": "저장된 문장이 없습니다"}), 404

        # 검색어 임베딩 생성
        query_embedding = get_upstage_embeddings(query)[0]
        query_embedding_np = np.array(query_embedding)

        # 각 저장된 문장과의 유사도 계산
        results = []
        for item in db["sentences"]:
            stored_embedding = np.array(item["embedding"])
            similarity = cosine_similarity([query_embedding_np], [stored_embedding])[0][0]
            results.append({
                "text": item["text"],
                "similarity": round(similarity, 4),
                "timestamp": item.get("timestamp", "")
            })

        # 유사도 높은 순으로 정렬
        results.sort(key=lambda x: x["similarity"], reverse=True)

        return jsonify({"results": results})
    
    except Exception as e:
        return jsonify({"error": str(e)}), 500`;
                
                html += createCodeBlock('백엔드 코드', backendCode);
                
                html += '</div>';
                
                container.innerHTML = html;
                
                // 코드 블록 토글 이벤트 추가
                addCodeBlockToggleEvents();
            }
            
            // 코드 블록 생성 함수
            function createCodeBlock(title, code) {
                return `
                    <div class="code-block">
                        <div class="code-header">
                            <h4>${title}</h4>
                            <span class="toggle-icon">▼</span>
                        </div>
                        <div class="code-content">
                            <pre>${code}</pre>
                        </div>
                    </div>
                `;
            }
            
            // 코드 블록 토글 이벤트 추가 함수
            function addCodeBlockToggleEvents() {
                document.querySelectorAll('.code-header').forEach(header => {
                    header.addEventListener('click', function() {
                        const content = this.nextElementSibling;
                        const icon = this.querySelector('.toggle-icon');
                        
                        content.classList.toggle('expanded');
                        icon.classList.toggle('expanded');
                    });
                });
            }
        });
    </script>
</body>
</html>
